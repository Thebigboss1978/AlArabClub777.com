<!--
  ⟁ AlArabClub777 — Vision Gate — Final Interactive Piece
  Author: العرّاب (Sharif AlShawish)
  Purpose: Single-file interactive 3D+Canvas HTML artwork.
  Features:
    • Three.js 3D parallax background (rings + stars)
    • 2D overlay "glyph-particles" center (THEBLACKHOLE) — persistent via localStorage
    • Mouse+Click becomes single "focus entity" (bind on first click)
    • Keypress letters add to symbol pool (persistent)
    • Click-speed drives generation intensity (more clicks => stronger "explode")
    • Touch support, save/load state, signature embedded
  Usage: Save as a .html file and open in a modern browser (Chrome/Edge/Firefox/Safari).
  Signature (visible & stored): AlArabClub777 | العرّاب
-->

<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>⟁AlArab⟁777 Vision Gate⟁</title>

<style>
  :root{
    --bg1:#07060b; --bg2:#00112b; --accent:#7dd3fc; --gold:#ffd166;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));font-family:Inter,ui-sans-serif,system-ui,monospace;color:#ddd;overflow:hidden}
  #wrap{position:fixed;inset:0;display:block}
  canvas#overlay{position:absolute;left:0;top:0;width:100%;height:100%;z-index:5;pointer-events:none}
  #three-container{position:absolute;left:0;top:0;width:100%;height:100%;z-index:0}
  .ui {
    position:fixed; left:12px; bottom:12px; z-index:20;
    background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.03);
    padding:8px 10px; border-radius:10px; color:#e6f7ff; font-size:13px;
    backdrop-filter: blur(6px);
  }
  .signature {
    position:fixed; right:12px; bottom:12px; z-index:20;
    font-size:12px; color:var(--gold); text-shadow:0 0 6px rgba(255,209,102,0.15);
    background:linear-gradient(0deg, rgba(255,255,255,0.02), transparent);
    padding:6px 8px; border-radius:8px; border:1px solid rgba(255,215,102,0.06);
    user-select:none;
  }
  .hint {font-size:12px; opacity:0.9}
  .badge {display:inline-block;padding:3px 6px;border-radius:6px;background:rgba(125,211,252,0.08);color:var(--accent);margin-left:6px;font-weight:600}
</style>
</head>
<body>
  <div id="wrap">
    <div id="three-container"></div>
    <canvas id="overlay" aria-hidden="true"></canvas>
    <div class="ui" id="ui">
      <div class="hint">اضغط داخل الدائرة المركزية للـ bind — الضغط الأول يجمع المؤشر والكتلة كـ كيان واحد.</div>
      <div style="margin-top:6px">
        <span class="hint">أكتب حروفًا لإضافتها للمجموعة (symbols)</span>
        <span class="badge" id="countBadge">—</span>
      </div>
      <div style="margin-top:6px">
        <small class="hint">ضغطات الآن: <span id="clickRate">0</span>/s</small>
      </div>
    </div>

    <div class="signature" id="sig">AlArabClub777 | العرّاب</div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
  /* -------------------------
     CONFIG & LOCAL STORAGE KEYS
     ------------------------- */
  const STORAGE_KEYS = {
    PARTICLES: 'alArab_particles_v2',
    SYMBOLS: 'alArab_symbols_v2',
    STATE: 'alArab_state_v2'
  };

  /* -------------------------
     UTILITIES
     ------------------------- */
  const rand = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

  /* -------------------------
     Symbol pool (persistent)
     ------------------------- */
  let symbolPool = (() => {
    try {
      const s = localStorage.getItem(STORAGE_KEYS.SYMBOLS);
      if (s) return JSON.parse(s);
    } catch(e) {}
    // default symbols (Arabic + glyphs + dots)
    return ['𓂀','𓁹','7•7','·','𓁹·𓁹',':','𓁹؛𓁹','*','۞','7','•77','·','█','▲','◇','أ','ب','ت'];
  })();

  function saveSymbols(){ try{ localStorage.setItem(STORAGE_KEYS.SYMBOLS, JSON.stringify(symbolPool)); }catch(e){} }
  function addSymbol(ch){ if(!ch) return; symbolPool.unshift(ch); if(symbolPool.length>120) symbolPool.length=120; saveSymbols(); updateBadge(); }

  function updateBadge(){ document.getElementById('countBadge').textContent = symbolPool.length + ' symbols'; }
  updateBadge();

  /* -------------------------
     THREE.JS: background depth & parallax
     ------------------------- */
  const threeContainer = document.getElementById('three-container');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 2000);
  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  threeContainer.appendChild(renderer.domElement);

  camera.position.set(0,0,320);

  // subtle starfield using points
  const starGeo = new THREE.BufferGeometry();
  const starCount = 600;
  const starPos = new Float32Array(starCount*3);
  for(let i=0;i<starCount;i++){
    starPos[i*3+0] = rand(-1500,1500);
    starPos[i*3+1] = rand(-1000,1000);
    starPos[i*3+2] = rand(-1200,600);
  }
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
  const starMat = new THREE.PointsMaterial({color:0xa6f0ff, size:1.7, transparent:true, opacity:0.28});
  const stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  // rotating rings (fixed in world but camera parallax moves)
  const rings = new THREE.Group();
  for(let i=0;i<4;i++){
    const geo = new THREE.TorusGeometry(80 + i*55, 2.5 + i*0.9, 10, 120);
    const mat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent:true, opacity: 0.06 + i*0.02});
    const tor = new THREE.Mesh(geo, mat);
    tor.rotation.x = Math.PI/2 * 0.95;
    tor.rotation.z = (i%2?0.2:-0.2)*(i+1);
    rings.add(tor);
  }
  scene.add(rings);

  // rotating spiritual cube (subtle)
  const cubeGroup = new THREE.Group();
  const cubeGeo = new THREE.BoxGeometry(28,28,28);
  const cubeMat = new THREE.MeshStandardMaterial({color:0xffdd77, metalness:0.2, roughness:0.6, transparent:true, opacity:0.9});
  const cubeMesh = new THREE.Mesh(cubeGeo,cubeMat);
  cubeGroup.add(cubeMesh);
  // light
  const pLight = new THREE.PointLight(0xfff0d0, 0.6, 800);
  pLight.position.set(200,200,200);
  scene.add(pLight);
  scene.add(cubeGroup);

  /* -------------------------
     Overlay canvas: glyph particles (THEBLACKHOLE)
     ------------------------- */
  const overlay = document.getElementById('overlay');
  const ctx = overlay.getContext('2d');

  function resizeCanvas(){
    overlay.width = innerWidth * devicePixelRatio;
    overlay.height = innerHeight * devicePixelRatio;
    overlay.style.width = innerWidth+'px';
    overlay.style.height = innerHeight+'px';
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // state & particles
  const center = { x: innerWidth/2, y: innerHeight/2 };
  const RADIUS = Math.min(innerWidth, innerHeight) * 0.18; // circle radius
  let particles = []; // {x,y,baseX,baseY,char,glow,vx,vy}
  let isExploded = false;
  let nextCycle = Date.now() + rand(5000,22000);

  // load particles from storage
  function loadParticles(){
    try{
      const raw = localStorage.getItem(STORAGE_KEYS.PARTICLES);
      if(raw){
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed) && parsed.length>12){
          return parsed.map(p=>({ ...p, vx:0, vy:0 }));
        }
      }
    }catch(e){}
    return createParticles(800); // fallback
  }

  function saveParticles(){
    try{
      const dump = particles.map(p=>({
        x:p.x, y:p.y, baseX:p.baseX, baseY:p.baseY, char:p.char, glow:p.glow
      }));
      localStorage.setItem(STORAGE_KEYS.PARTICLES, JSON.stringify(dump));
    }catch(e){}
  }

  function createParticles(limit=800){
    const arr=[];
    for(let i=0;i<limit;i++){
      const a = Math.random()*Math.PI*2;
      const r = Math.sqrt(Math.random()) * (RADIUS-2);
      const bx = Math.round(center.x + Math.cos(a)*r);
      const by = Math.round(center.y + Math.sin(a)*r);
      arr.push({
        x: bx + rand(-4,4),
        y: by + rand(-4,4),
        baseX: bx,
        baseY: by,
        char: symbolPool[Math.floor(Math.random()*symbolPool.length)],
        glow: Math.random()*0.9 + 0.1,
        vx: 0, vy: 0
      });
    }
    return arr;
  }

  // initial load
  particles = loadParticles();

  /* -------------------------
     FOCUS entity: binds mouse+click into one unit
     ------------------------- */
  let focus = {
    bound: (() => {
      try{ const s=localStorage.getItem(STORAGE_KEYS.STATE); if(s){ return JSON.parse(s).bound||false }}catch(e){} return false;
    })(),
    x: center.x, y: center.y,
    easing: 0.08
  };

  // click-rate measurement (clicks per second)
  let clickTimestamps = [];

  // helper: update click rate
  function recordClick(){
    const now = Date.now();
    clickTimestamps.push(now);
    // keep last 1.2s
    clickTimestamps = clickTimestamps.filter(t=>now - t < 1200);
    document.getElementById('clickRate').textContent = clickTimestamps.length.toString();
  }

  // explode/regroup functions (driven by clicks & auto cycles)
  function explodeParticles(intensity=1){
    for(const p of particles){
      p.vx = (Math.random()-0.5) * 20 * intensity;
      p.vy = (Math.random()-0.5) * 20 * intensity;
    }
    isExploded = true;
    nextCycle = Date.now() + rand(4000,16000);
    saveParticles();
    saveState();
  }
  function regroupParticles(){
    isExploded = false;
    nextCycle = Date.now() + rand(7000,22000);
    saveParticles();
    saveState();
  }

  /* -------------------------
     Input handling: click/touch/key
     ------------------------- */
  function pointerMove(x,y){
    pointer.x = x; pointer.y = y;
  }
  const pointer = { x: center.x, y: center.y, down:false };

  // click/tap => toggle bind if inside radius, else small nudge
  overlay.addEventListener('click', (e)=>{
    const cx = e.clientX, cy = e.clientY;
    const d = Math.hypot(cx-center.x, cy-center.y);
    recordClick();
    if(d <= RADIUS){
      // inside: toggle bound
      focus.bound = !focus.bound;
      // if binding now, position focus to pointer
      if(focus.bound){
        focus.x = cx; focus.y = cy;
        // quick visual nudge: explode smaller intensity
        explodeParticles(1.2);
      } else {
        regroupParticles();
      }
      saveState();
    } else {
      // outside: small splash/explosion near pointer
      explodeAt(cx,cy,1.4);
    }
  }, {passive:true});

  // touch support
  overlay.addEventListener('touchstart', (e)=>{
    const t = e.touches[0];
    pointerMove(t.clientX,t.clientY);
    pointer.down=true;
  }, {passive:true});
  overlay.addEventListener('touchmove', (e)=>{
    const t = e.touches[0];
    pointerMove(t.clientX,t.clientY);
  }, {passive:true});
  overlay.addEventListener('touchend', (e)=>{
    pointer.down=false;
  }, {passive:true});

  // mouse move
  overlay.addEventListener('mousemove', (e)=>{ pointerMove(e.clientX,e.clientY); }, {passive:true});

  // keyboard: add char to symbol pool (any printable char)
  window.addEventListener('keydown', (e)=>{
    if(e.key && e.key.length===1){
      addSymbol(e.key);
      // quick local regeneration: recolor some particles
      for(let i=0;i<Math.min(16,particles.length);i++){
        const p = particles[Math.floor(Math.random()*particles.length)];
        p.char = symbolPool[Math.floor(Math.random()*symbolPool.length)];
      }
      saveParticles();
    }
    // space = force explosion
    if(e.code === 'Space'){
      explodeParticles(1.6);
      recordClick();
    }
  });

  // explode at position with intensity: spawn little local push
  function explodeAt(px,py,intensity=1){
    for(const p of particles){
      const dx = p.x - px, dy = p.y - py;
      const dist = Math.max(12, Math.hypot(dx,dy));
      const power = clamp((200 - dist)/200, 0,1) * intensity;
      p.vx += (dx/dist) * 8 * power * rand(0.6,1.6);
      p.vy += (dy/dist) * 8 * power * rand(0.6,1.6);
    }
    isExploded = true;
    nextCycle = Date.now() + rand(4000,13000);
    saveParticles();
  }

  /* -------------------------
     STATE persistence
     ------------------------- */
  function saveState(){
    try{
      const st = { bound: focus.bound, focusX: focus.x, focusY: focus.y, timestamp: Date.now() };
      localStorage.setItem(STORAGE_KEYS.STATE, JSON.stringify(st));
    }catch(e){}
  }

  /* -------------------------
     ANIMATION LOOP
     ------------------------- */
  let last = performance.now();
  function loop(now){
    const dt = (now - last) / 1000;
    last = now;

    // THREE updates (camera parallax to pointer)
    // slight camera shift towards pointer to create depth effect
    const camTargetX = (pointer.x - innerWidth/2) * 0.0006 * 160; 
    const camTargetY = (pointer.y - innerHeight/2) * -0.0006 * 160;
    camera.position.x += (camTargetX - camera.position.x) * 0.06;
    camera.position.y += (camTargetY - camera.position.y) * 0.06;
    camera.lookAt(0,0,0);
    // rotate rings & cube slowly
    rings.rotation.z += 0.0008 + Math.sin(now*0.0003)*0.0006;
    cubeGroup.rotation.x += 0.0024; cubeGroup.rotation.y += 0.0031;
    // subtle star twinkle via opacity (update material)
    starMat.opacity = 0.22 + Math.sin(now*0.0023)*0.04;

    renderer.render(scene, camera);

    // overlay draw
    ctx.clearRect(0,0,overlay.width, overlay.height);
    ctx.save();
    ctx.scale(1,1);

    // central circle (visual guide)
    ctx.beginPath();
    ctx.arc(center.x, center.y, RADIUS, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(8,18,30,0.22)';
    ctx.fill();
    ctx.lineWidth = 1.0;
    ctx.strokeStyle = 'rgba(120,200,255,0.06)';
    ctx.stroke();
    ctx.closePath();

    // focus behavior: if bound, focus.x/y chase pointer
    if(focus.bound){
      focus.x += (pointer.x - focus.x) * focus.easing;
      focus.y += (pointer.y - focus.y) * focus.easing;
    } else {
      // idle gentle drift toward center when not bound
      focus.x += ((center.x) - focus.x) * 0.01;
      focus.y += ((center.y) - focus.y) * 0.01;
    }

    // draw focus halo
    ctx.beginPath();
    const haloR = 26 + Math.abs(Math.sin(now*0.003))*8;
    const grd = ctx.createRadialGradient(focus.x, focus.y, haloR*0.2, focus.x, focus.y, haloR*2.6);
    grd.addColorStop(0, 'rgba(125,211,252,0.9)');
    grd.addColorStop(0.3, 'rgba(125,211,252,0.18)');
    grd.addColorStop(1, 'rgba(10,18,30,0)');
    ctx.fillStyle = grd;
    ctx.arc(focus.x, focus.y, haloR*2.6, 0, Math.PI*2);
    ctx.fill();
    ctx.closePath();

    // particle physics & render
    for(const p of particles){
      if(isExploded){
        p.x += p.vx * (0.98 + Math.random()*0.04);
        p.y += p.vy * (0.98 + Math.random()*0.04);
        p.vx *= 0.985; p.vy *= 0.985;
      } else {
        // relax toward base with a slight offset when focus is near
        const dx = (p.baseX - p.x);
        const dy = (p.baseY - p.y);
        p.x += dx * 0.055;
        p.y += dy * 0.055;
      }

      // affect by focus entity as if focus "rubs" or "pulls" nearby particles
      const fx = focus.x, fy = focus.y;
      const ddx = p.x - fx, ddy = p.y - fy;
      const dist = Math.hypot(ddx,ddy);
      // when bound: cluster moves with focus so particles are relative; when not bound only slight influence
      if(dist < 160){
        // if bound stronger follow
        const force = focus.bound ? (1 - dist/160) * 0.28 : (1 - dist/160) * 0.06;
        p.x -= (p.x - (p.baseX + (fx-center.x)*0.06)) * force;
        p.y -= (p.y - (p.baseY + (fy-center.y)*0.06)) * force;
      }

      // slight flicker based on glow
      const flick = 0.5 + Math.sin(now*0.003 + p.x*0.01 + p.y*0.01) * 0.5;
      const alpha = clamp(p.glow * flick, 0.08, 1);
      ctx.fillStyle = `rgba(255,215,100,${alpha})`;
      // draw glyph
      ctx.font = `${9 + Math.round(Math.sin(p.x*0.005+p.y*0.005)*2)}px monospace`;
      ctx.fillText(p.char, p.x - 3, p.y + 1);
    }

    ctx.restore();

    // auto cycle
    if(Date.now() > nextCycle){
      if(!isExploded) explodeParticles(1 + Math.random()*1.6);
      else regroupParticles();
    }

    // save state periodically
    if(now % 4000 < 16) {
      saveParticles();
      saveState();
    }

    requestAnimationFrame(loop);
  }

  // start rendering
  requestAnimationFrame(loop);

  /* -------------------------
     window resize observer to reposition center/particles base when needed
     ------------------------- */
  window.addEventListener('resize', ()=>{
    // recompute center & bases: simple approach - reinitialize circle bases but preserve particle chars
    const old = particles.slice(0, Math.min(particles.length, 1200));
    particles = createParticles(Math.max(400, old.length));
    // reassign chars from old to new for continuity
    for(let i=0;i<Math.min(old.length, particles.length);i++){
      particles[i].char = old[i].char;
    }
    saveParticles();
  });

  /* -------------------------
     Expose some quick debug helpers (optional)
     ------------------------- */
  window.AlArab = {
    explode: explodeParticles,
    regroup: regroupParticles,
    addSymbol,
    saveState,
    saveParticles
  };

  // initial save
  saveParticles();
  saveState();

  </script>

  <!-- Visible comment signature at end of file (permanent in HTML) -->
  <!-- Signed: AlArabClub777 | العرّاب — Save & Persist Enabled — Generated: ⟁VisionGate⟁ -->
</body>
</html>